"""VulnerabilityComparator.py -- Correlate Checkov (Micro) and Threat Model (Macro) findings.

Joins per-delta results from CheckovScanner.py and DeltaThreatModelDiffGenerator.py,
maps to attack classes, and computes composite scores.  No SQLite.

Classes
-------
VulnerabilityComparator
    Correlates Checkov and Threat Model findings per delta.
ComparisonResult
    Full comparison result for one extraction delta.
"""

from __future__ import annotations

import json
import logging
from collections import Counter
from dataclasses import asdict, dataclass, field
from pathlib import Path
from typing import Any, Dict, List

import yaml

logger = logging.getLogger(__name__)

_DEFAULT_SCORING_CONFIG_PATH = (
    Path(__file__).resolve().parent / "config" / "comparator_scoring_config.yaml"
)
_DEFAULT_SCORING_CONFIG: Dict[str, Any] = {
    "normalization": {
        "checkov_delta_scale": 5.0,
        "threat_count_scale": 3.0,
        "risk_delta_scale": 15.0,
        "checkov_signal_cap": 1.0,
        "threat_count_cap": 1.0,
        "risk_delta_cap": 1.0,
    },
    "threat_signal": {
        "threat_count_weight": 1.0,
        "risk_delta_weight": 1.0,
    },
}


# ---------------------------------------------------------------------------
# Data class for per-delta comparison results
# ---------------------------------------------------------------------------
@dataclass
class ComparisonResult:
    """Comparison result for one extraction delta."""

    commit_sha: str
    file_path: str
    commit_message: str
    commit_date: str
    author: str
    keywords_matched: List[str]

    # Checkov (Micro View)
    checkov_before_count: int = 0
    checkov_after_count: int = 0
    checkov_delta: int = 0
    checkov_findings_after: List[Dict[str, Any]] = field(
        default_factory=list
    )

    # Threat Model (Macro View)
    threat_finding_count: int = 0
    threat_risk_delta: int = 0
    threat_findings: List[Dict[str, Any]] = field(default_factory=list)

    # Combined analysis
    attack_class: str = ""
    composite_score: float = 0.0
    posture_direction: str = "neutral"  # regression | improvement | neutral
    is_csi: bool = False                # Commit of Security Interest
    macro_only: bool = False            # detected by Macro but not Micro
    micro_only: bool = False            # detected by Micro but not Macro

    # Labels for Macro View context
    labels_before: List[str] = field(default_factory=list)
    labels_after: List[str] = field(default_factory=list)


# ---------------------------------------------------------------------------
# Main comparator class
# ---------------------------------------------------------------------------
class VulnerabilityComparator:
    """Correlate Checkov and Threat Model findings per delta.

    Parameters
    ----------
    config : dict
        Parsed ``pipeline_config.yaml`` contents.
    """

    def __init__(self, config: dict) -> None:
        comp_cfg = config.get("comparison", {})
        weights = comp_cfg.get("weights", {})
        self.w_keyword: float = weights.get("keyword", 0.10)
        self.w_checkov: float = weights.get("checkov", 0.45)
        self.w_threat: float = weights.get("threat_model", 0.45)
        self.severity_weights: Dict[str, int] = comp_cfg.get(
            "severity_weights",
            {"CRITICAL": 10, "HIGH": 5, "MEDIUM": 2, "LOW": 1, "INFO": 0},
        )
        self.csi_threshold: float = comp_cfg.get("csi_threshold", 0.30)

        scoring_cfg = self._load_scoring_config(comp_cfg)
        norm_cfg = scoring_cfg.get("normalization", {})
        threat_signal_cfg = scoring_cfg.get("threat_signal", {})

        self.checkov_delta_scale: float = max(
            0.0001, float(norm_cfg.get("checkov_delta_scale", 5.0))
        )
        self.threat_count_scale: float = max(
            0.0001, float(norm_cfg.get("threat_count_scale", 3.0))
        )
        self.risk_delta_scale: float = max(
            0.0001, float(norm_cfg.get("risk_delta_scale", 15.0))
        )
        self.checkov_signal_cap: float = max(
            0.0, float(norm_cfg.get("checkov_signal_cap", 1.0))
        )
        self.threat_count_cap: float = max(
            0.0, float(norm_cfg.get("threat_count_cap", 1.0))
        )
        self.risk_delta_cap: float = max(
            0.0, float(norm_cfg.get("risk_delta_cap", 1.0))
        )

        self.threat_count_weight: float = max(
            0.0, float(threat_signal_cfg.get("threat_count_weight", 1.0))
        )
        self.risk_delta_weight: float = max(
            0.0, float(threat_signal_cfg.get("risk_delta_weight", 1.0))
        )

    @staticmethod
    def _load_scoring_config(comp_cfg: Dict[str, Any]) -> Dict[str, Any]:
        """Load optional comparator scoring config from YAML."""
        raw_path = comp_cfg.get("scoring_config_path")
        cfg_path = (
            _DEFAULT_SCORING_CONFIG_PATH
            if not raw_path
            else Path(str(raw_path))
        )
        if not cfg_path.is_absolute():
            cfg_path = Path(__file__).resolve().parent / cfg_path
        if not cfg_path.exists():
            logger.info(
                "Comparator scoring config not found at %s; using built-in defaults.",
                cfg_path,
            )
            return dict(_DEFAULT_SCORING_CONFIG)
        try:
            with open(cfg_path, "r", encoding="utf-8") as f:
                loaded = yaml.safe_load(f) or {}
            if not isinstance(loaded, dict):
                logger.warning(
                    "Invalid comparator scoring config (expected mapping): %s",
                    cfg_path,
                )
                return dict(_DEFAULT_SCORING_CONFIG)
            configured = loaded.get("comparison_scoring", loaded)
            if not isinstance(configured, dict):
                logger.warning(
                    "Invalid comparison_scoring section (expected mapping): %s",
                    cfg_path,
                )
                return dict(_DEFAULT_SCORING_CONFIG)
            merged: Dict[str, Any] = dict(_DEFAULT_SCORING_CONFIG)
            for section in ("normalization", "threat_signal"):
                merged_section = dict(_DEFAULT_SCORING_CONFIG.get(section, {}))
                configured_section = configured.get(section, {})
                if isinstance(configured_section, dict):
                    merged_section.update(configured_section)
                merged[section] = merged_section
            return merged
        except Exception as exc:
            logger.warning(
                "Failed to load comparator scoring config from %s: %s",
                cfg_path,
                exc,
            )
            return dict(_DEFAULT_SCORING_CONFIG)

    # -----------------------------------------------------------------
    # Public API
    # -----------------------------------------------------------------
    def compare(
        self,
        deltas: List[Dict[str, Any]],
        checkov_results: List[Dict[str, Any]],
        threat_results: List[Dict[str, Any]],
    ) -> List[ComparisonResult]:
        """Join extraction deltas with Checkov and threat model results.

        Parameters
        ----------
        deltas : list[dict]
            Original extraction output
            (``SecurityDeltaExtractor.run()``).
        checkov_results : list[dict]
            Serialised output from ``CheckovScanner.scan_deltas()``.
        threat_results : list[dict]
            Serialised output from
            ``DeltaThreatModelDiffGenerator.model_deltas()``.

        Returns
        -------
        list[ComparisonResult]
            One result per delta, sorted by composite score descending.
        """
        # Index by (sha, file_path)
        ck_index = self._build_index(checkov_results)
        tm_index = self._build_index(threat_results)

        results: List[ComparisonResult] = []

        for delta in deltas:
            sha = delta.get("commit_sha", "")
            fpath = delta.get("file", "")
            key = f"{sha}:{fpath}"

            ck = ck_index.get(key, {})
            tm = tm_index.get(key, {})

            # Gather attack classes from both sources
            checkov_acs = self._extract_checkov_acs(ck)
            threat_acs = self._extract_threat_acs(tm)
            attack_class = self._majority_vote(checkov_acs + threat_acs)

            # Keyword score (diminishing returns formula)
            kw_matched = delta.get("keywords_matched", [])
            kw_score = (
                1.0 - (1.0 / (1.0 + len(kw_matched)))
                if kw_matched
                else 0.0
            )

            ck_delta = ck.get("delta", 0)
            threat_count = tm.get("finding_count", 0)
            risk_delta = tm.get("risk_delta", 0)

            # Micro/Macro detection flags
            micro_detected = ck_delta != 0
            macro_detected = threat_count > 0

            # Composite score
            composite = self._compute_composite_score(
                kw_score, ck_delta, threat_count, risk_delta
            )

            # Posture direction
            direction = self._determine_posture_direction(
                risk_delta, ck_delta
            )

            result = ComparisonResult(
                commit_sha=sha,
                file_path=fpath,
                commit_message=delta.get("commit_message", ""),
                commit_date=delta.get("commit_date", ""),
                author=delta.get("author", ""),
                keywords_matched=kw_matched,
                checkov_before_count=ck.get("before_count", 0),
                checkov_after_count=ck.get("after_count", 0),
                checkov_delta=ck_delta,
                checkov_findings_after=ck.get("after_findings", []),
                threat_finding_count=threat_count,
                threat_risk_delta=risk_delta,
                threat_findings=tm.get("findings", []),
                attack_class=attack_class,
                composite_score=round(composite, 4),
                posture_direction=direction,
                is_csi=composite >= self.csi_threshold,
                macro_only=macro_detected and not micro_detected,
                micro_only=micro_detected and not macro_detected,
                labels_before=tm.get("before_labels", []),
                labels_after=tm.get("after_labels", []),
            )
            results.append(result)

        # Sort by composite score descending
        results.sort(key=lambda r: r.composite_score, reverse=True)
        return results

    @staticmethod
    def save_json(
        results: List[ComparisonResult], output_path: str
    ) -> None:
        """Save comparison results to JSON."""
        data = [asdict(r) for r in results]
        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, default=str, ensure_ascii=False)
        logger.info(
            "Saved %d comparison results to %s", len(data), output_path
        )

    # -----------------------------------------------------------------
    # Internal helpers
    # -----------------------------------------------------------------
    @staticmethod
    def _build_index(
        results: List[Dict[str, Any]],
    ) -> Dict[str, Dict[str, Any]]:
        """Index results by 'commit_sha:file_path'."""
        index: Dict[str, Dict[str, Any]] = {}
        for r in results:
            key = f"{r.get('commit_sha', '')}:{r.get('file_path', '')}"
            index[key] = r
        return index

    def _compute_composite_score(
        self,
        kw_score: float,
        ck_delta: int,
        threat_count: int,
        risk_delta: int,
    ) -> float:
        """Weighted composite score in [0, 1].

        Adapted from monitor/pipeline/correlate.py.  SecBERT weight is
        dropped; its share is split between Checkov and threat model.
        """
        checkov_signal = min(
            abs(ck_delta) / self.checkov_delta_scale,
            self.checkov_signal_cap,
        )
        threat_count_signal = min(
            threat_count / self.threat_count_scale,
            self.threat_count_cap,
        )
        risk_signal = min(
            abs(risk_delta) / self.risk_delta_scale,
            self.risk_delta_cap,
        )
        threat_weight_total = self.threat_count_weight + self.risk_delta_weight
        if threat_weight_total <= 0:
            threat_signal = 0.0
        else:
            threat_signal = (
                (threat_count_signal * self.threat_count_weight)
                + (risk_signal * self.risk_delta_weight)
            ) / threat_weight_total

        score = (
            self.w_keyword * kw_score
            + self.w_checkov * checkov_signal
            + self.w_threat * threat_signal
        )
        return min(max(score, 0.0), 1.0)

    @staticmethod
    def _majority_vote(acs: List[str]) -> str:
        """Return the most common attack class, or empty string."""
        if not acs:
            return ""
        counter = Counter(acs)
        return counter.most_common(1)[0][0]

    @staticmethod
    def _determine_posture_direction(
        risk_delta: int, ck_delta: int
    ) -> str:
        """Return 'regression', 'improvement', or 'neutral'."""
        if risk_delta > 0 or ck_delta > 0:
            return "regression"
        if risk_delta < 0 or ck_delta < 0:
            return "improvement"
        return "neutral"

    @staticmethod
    def _extract_checkov_acs(ck_result: Dict[str, Any]) -> List[str]:
        """Extract attack class IDs from Checkov results."""
        acs: List[str] = []
        for finding in ck_result.get("after_findings", []):
            acs.extend(finding.get("attack_classes", []))
        return acs

    @staticmethod
    def _extract_threat_acs(
        tm_result: Dict[str, Any],
    ) -> List[str]:
        """Extract attack class IDs from threat model results."""
        return [
            f["attack_class"]
            for f in tm_result.get("findings", [])
            if f.get("attack_class")
        ]
